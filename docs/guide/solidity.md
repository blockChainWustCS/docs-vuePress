# Solidity学习笔记

### 函数四种访问权限

|  修饰词  |   含义   | 内部是否可访问 | 外部是否可访问 | 子类能否继承 | 备注                   |
| :------: | :------: | :------------: | :------------: | :----------: | :--------------------- |
| private  | 私有函数 |       ✔        |       ✖        |      ✖       | 只有自己能用           |
| internal | 内部函数 |       ✔        |       ✖        |      ✔       | 只有自己和子合约可用   |
| external | 外部函数 |       ✖        |       ✔        |      ✔       | 只有外部和子合约可调用 |
|  public  | 公共函数 |       ✔        |       ✔        |      ✔       | 所有都能用             |

#### payable修饰符

`payable` 方法是让 Solidity 和以太坊变得如此酷的一部分 —— 它们是一种可以接收以太(eth)的特殊函数。

先放一下。当你在调用一个普通网站服务器上的API函数的时候，你无法用你的函数传送美元——你也不能传送比特币。

但是在以太坊中， 因为钱 (_以太_), 数据 (*事务负载*)， 以及合约代码本身都存在于以太坊。你可以在同时调用函数 **并**付钱给另外一个合约。

这就允许出现很多有趣的逻辑， 比如向一个合约要求支付一定的钱来运行一个函数。

#### 例子

```solidity
contract OnlineStore {
  function buySomething() external payable {
    // 检查以确定0.001以太发送出去来运行函数:
    require(msg.value == 0.001 ether);
    // 如果为真，一些用来向函数调用者发送数字内容的逻辑
    transferThing(msg.sender);
  }
}
```

在这里，`msg.value` 是一种可以查看向合约发送了多少以太的方法，另外 `ether` 是一个內建单元。

### 函数两种状态

| 状态      | 作用                                | 备注                                   |
| --------- | ----------------------------------- | -------------------------------------- |
| (default) | 默认不用显式写出，正常函数          |                                        |
| view      | 标记该函数只读不可写，不会消耗gas   | 理解为只能读取链上的数据               |
| pure      | 标记该函数不可读不可写，不会消耗gas | 理解为不与链上的数据交互，可与参数交互 |

## 命名规范

1. 变量名称使用**驼峰命名法**，例如 newData

2. 内部函数和私有函数名称用下划线开头

3. 函数参数名称用下划线开头

   示例：

   ```Solidity
   function _createZombie(string _name, uint _dna) internal {...}
   ```

4. uint 和uint256是一样的，但是ERC等规范使用uint256，所以统一使用uint256，尽量少用简写uint

## storge和memory的区别

| 类别   | 描述                                                         | 备注           |
| ------ | ------------------------------------------------------------ | -------------- |
| storge | 永久存储在区块链上，所有的操作都会有记录，消耗资源，即放入所有节点，外部存储 | 非常昂贵       |
| memory | 只是写入内存，不会同步所有节点，执行完毕后即释放，不消耗链资源 | 多用于处理循环 |

**默认情况下** （不需要显式声明）

在函数之外的变量会被声明为Storage形式永久存储在区块链上

在函数内部的变量会被声明为Memory形式，函数调用完成后即释放

**特殊情况**（需要显式声明）

主要是用于处理函数内的 **结构体** 和 **数组** 时会需要用到显式声明，如果未声明，编译器会给出警告，示例：

```Solidity
contract SandwichFactory {
  struct Sandwich {
    string name;
    string status;
  }

  Sandwich[] sandwiches;

  function eatSandwich(uint _index) public {
    // Sandwich mySandwich = sandwiches[_index];

    // ^ 看上去很直接，不过 Solidity 将会给出警告
    // 告诉你应该明确在这里定义 `storage` 或者 `memory`。

    // 所以你应该明确定义 `storage`:
    Sandwich storage mySandwich = sandwiches[_index];
    // ...这样 `mySandwich` 是指向 `sandwiches[_index]`的指针
    // 在存储里，另外...
    mySandwich.status = "Eaten!";
    // ...这将永久把 `sandwiches[_index]` 变为区块链上的存储

    // 如果你只想要一个副本，可以使用`memory`:
    Sandwich memory anotherSandwich = sandwiches[_index + 1];
    // ...这样 `anotherSandwich` 就仅仅是一个内存里的副本了
    // 另外
    anotherSandwich.status = "Eaten!";
    // ...将仅仅修改临时变量，对 `sandwiches[_index + 1]` 没有任何影响
    // 不过你可以这样做:
    sandwiches[_index + 1] = anotherSandwich;
    // ...如果你想把副本的改动保存回区块链存储
  }
}
```

## keccak256

keccak256是solidity内置函数，返回一个256位二进制字符串，只要参数一致，即可返回相同结果，无法逆向，主要用于

1. 判断字符串是否相等（唯一办法）

2. 生成随机数（不是100%安全）

   ### 用 keccak256 来制造随机数。

   Solidity 中最好的随机数生成器是 `keccak256` 哈希函数.

   我们可以这样来生成一些随机数

   ```solidity
   // 生成一个0到100的随机数:
   uint randNonce = 0;
   uint random = uint(keccak256(now, msg.sender, randNonce)) % 100;
   randNonce++;
   uint random2 = uint(keccak256(now, msg.sender, randNonce)) % 100;
   ```

   这个方法首先拿到 `now` 的时间戳、 `msg.sender`、 以及一个自增数 `nonce` （一个仅会被使用一次的数，这样我们就不会对相同的输入值调用一次以上哈希函数了）。

   然后利用 `keccak` 把输入的值转变为一个哈希值, 再将哈希值转换为 `uint`, 然后利用 `% 100` 来取最后两位, 就生成了一个0到100之间随机数了。

   ### 这个方法很容易被不诚实的节点攻击

   在以太坊上, 当你在和一个合约上调用函数的时候, 你会把它广播给一个节点或者在网络上的 ***transaction\*** 节点们。 网络上的节点将收集很多事务, 试着成为第一个解决计算密集型数学问题的人，作为“工作证明”，然后将“工作证明”(Proof of Work, PoW)和事务一起作为一个 ***block\*** 发布在网络上。

   一旦一个节点解决了一个PoW, 其他节点就会停止尝试解决这个 PoW, 并验证其他节点的事务列表是有效的，然后接受这个节点转而尝试解决下一个节点。

   **这就让我们的随机数函数变得可利用了**

   我们假设我们有一个硬币翻转合约——正面你赢双倍钱，反面你输掉所有的钱。假如它使用上面的方法来决定是正面还是反面 (`random >= 50` 算正面, `random < 50` 算反面)。

   如果我正运行一个节点，我可以 **只对我自己的节点** 发布一个事务，且不分享它。 我可以运行硬币翻转方法来偷窥我的输赢 — 如果我输了，我就不把这个事务包含进我要解决的下一个区块中去。我可以一直运行这个方法，直到我赢得了硬币翻转并解决了下一个区块，然后获利。

   ## 所以我们该如何在以太坊上安全地生成随机数呢

   因为区块链的全部内容对所有参与者来说是透明的， 这就让这个问题变得很难，它的解决方法不在本课程讨论范围，你可以阅读 [这个 StackOverflow 上的讨论](https://ethereum.stackexchange.com/questions/191/how-can-i-securely-generate-a-random-number-in-my-smart-contract) 来获得一些主意。 一个方法是利用 ***oracle\*** 来访问以太坊区块链之外的随机数函数。

   当然， 因为网络上成千上万的以太坊节点都在竞争解决下一个区块，我能成功解决下一个区块的几率非常之低。 这将花费我们巨大的计算资源来开发这个获利方法 — 但是如果奖励异常地高(比如我可以在硬币翻转函数中赢得 1个亿)， 那就很值得去攻击了。

   所以尽管这个方法在以太坊上不安全，在实际中，除非我们的随机函数有一大笔钱在上面，你游戏的用户一般是没有足够的资源去攻击的。

   因为在这个教程中，我们只是在编写一个简单的游戏来做演示，也没有真正的钱在里面，所以我们决定接受这个不足之处，使用这个简单的随机数生成函数。但是要谨记它是不安全的。

   ### 区块链结构图

   ![lo7Wh.png](https://s1.328888.xyz/2022/07/19/lo7Wh.png)

## 代币

一个 **_代币_** 在以太坊基本上就是一个遵循一些共同规则的智能合约——即它实现了所有其他代币合约共享的一组标准函数，例如 `transfer(address _to, uint256 _value)` 和 `balanceOf(address _owner)`.

在智能合约内部，通常有一个映射， `mapping(address => uint256) balances`，用于追踪每个地址还有多少余额。

（-----------------------划重点---------------------------）

*所以基本上**一个代币只是一个**追踪谁拥有多少该代币的**合约**，**和一些**可以让那些用户将他们的代币转移到其他地址的**函数**。*

### ERC20

为什么重要？

由于所有 ERC20 代币共享具有相同名称的同一组函数，它们都可以以相同的方式进行交互。

这意味着如果你构建的应用程序能够与一个 ERC20 代币进行交互，那么它就也能够与任何 ERC20 代币进行交互。 这样一来，将来你就可以轻松地将更多的代币添加到你的应用中，而无需进行自定义编码。 你可以简单地插入新的代币合约地址，然后哗啦，你的应用程序有另一个它可以使用的代币了。

其中一个例子就是交易所。 当交易所添加一个新的 ERC20 代币时，实际上它只需要添加与之对话的另一个智能合约。 用户可以让那个合约将代币发送到交易所的钱包地址，然后交易所可以让合约在用户要求取款时将代币发送回给他们。

交易所只需要实现这种转移逻辑一次，然后当它想要添加一个新的 ERC20 代币时，只需将新的合约地址添加到它的数据库即可。

### 其他代币标准（ERC721）

摘自僵尸游戏的例子：

对于像货币一样的代币来说，ERC20 代币非常酷。 但是要在我们僵尸游戏中代表僵尸就并不是特别有用。

首先，僵尸不像货币可以分割 —— 我可以发给你 0.237 以太，但是转移给你 0.237 的僵尸听起来就有些搞笑。

其次，并不是所有僵尸都是平等的。 你的2级僵尸"**Steve**"完全不能等同于我732级的僵尸"**H4XF13LD MORRIS 💯💯😎💯💯**"。（你差得远呢，*Steve*）。

有另一个代币标准更适合如 CryptoZombies 这样的加密收藏品——它们被称为***ERC721 代币.\***

<u>***ERC721 代币***是**不**能互换的，因为每个代币都被认为是唯一且不可分割的。 你只能以整个单位交易它们，并且每个单位都有唯一的 ID。</u> 这些特性正好让我们的僵尸可以用来交易。

> 请注意，使用像 ERC721 这样的标准的优势就是，我们不必在我们的合约中实现拍卖或托管逻辑，这决定了玩家能够如何交易／出售我们的僵尸。 如果我们符合规范，其他人可以为加密可交易的 ERC721 资产搭建一个交易所平台，我们的 ERC721 僵尸将可以在该平台上使用。 所以使用代币标准相较于使用你自己的交易逻辑有明显的好处。